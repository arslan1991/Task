"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require("react");
var saveAs = require("browser-filesaver");

var _require = require('react-bootstrap');

var ButtonToolbar = _require.ButtonToolbar;
var ButtonGroup = _require.ButtonGroup;
var Button = _require.Button;
var Input = _require.Input;
var Glyphicon = _require.Glyphicon;
var Navbar = _require.Navbar;
var Nav = _require.Nav;

function cons(x, list) {
	list = list.slice();
	list.unshift(x);
	return list;
}

function rest(list) {
	return list.slice(1);
}

function first(list) {
	return list[0];
}

var RootWidget = React.createClass({
	displayName: "RootWidget",

	componentDidMount: function componentDidMount() {
		var _this = this;

		// Keyboard shortcuts:
		// - Control-Z: undo
		// - Shift-Control-Z: redo
		// TODO: Control-S: save the current configuration
		//
		// Undo/redo shortcuts are disabled for Chrome due to the
		// following problem:
		//   At least on Chrome/Linux Control-Z triggers
		//   Chrome's own undo, which can apparently not be
		//   intercepted by the web page if Chrome has something to
		//   undo by itself.  So we get the odd behavior that after
		//   some editing typically
		//   - the first Control-Z undoes the last edit (via Chrome
		//     itself) and pushes this change on the app's undo
		//     stack,
		//   - the second Control-Z undoes the first change on the
		//     app's undo stack, i.e., it redoes the last edit,
		//   - more Control-Zs undo the edit again.
		//   Similarly a Control-Shift-Z may perform a Chrome redo,
		//   which is a change action for the app.  This is pushed on
		//   the undo stack and the redo stack is cleared, which is
		//   probably not what the user expects.
		this.getDOMNode().onkeypress = function (e) {
			function stop() {
				if (e.preventDefault) e.preventDefault();
				if (e.stopPropagation) e.stopPropagation();
			}
			// TODO: Search for a standard implementation for detecting specific keys.
			if (e.ctrlKey && !e.altKey && !e.metaKey && !e.shiftKey && e.key === "z" // Firefox
			// || e.keyCode === 26 // Chrome; disabled, see comment above
			) {
					_this._undo();
					stop();
				}
			if (e.ctrlKey && !e.altKey && !e.metaKey && e.shiftKey && e.key === "Z" // Firefox
			// || e.keyCode === 90 // Chrome; disabled, see comment above
			) {
					_this._redo();
					stop();
				}
		};
	},
	getInitialState: function getInitialState() {
		return {
			now: this.props.initialJSON,
			past: [],
			future: []
		};
	},
	_undo: function _undo() {
		var _state = this.state;
		var now = _state.now;
		var past = _state.past;
		var future = _state.future;

		if (past.length > 0) this.setState({
			now: first(past),
			past: rest(past),
			future: cons(now, future)
		});
	},
	_redo: function _redo() {
		var _state2 = this.state;
		var now = _state2.now;
		var past = _state2.past;
		var future = _state2.future;

		if (future.length > 0) this.setState({
			now: first(future),
			past: cons(now, past),
			future: rest(future)
		});
	},
	_reset: function _reset() {
		var _state3 = this.state;
		var now = _state3.now;
		var past = _state3.past;
		var future = _state3.future;

		this.setState({
			now: undefined,
			past: cons(now, past),
			future: []
		});
	},
	_save: function _save() {
		localStorage.openCPQ = JSON.stringify(this.state);
	},
	_restore: function _restore() {
		this.setState(JSON.parse(localStorage.openCPQ));
	},
	_import: function _import() {
		var _this2 = this;

		var fileReader = new FileReader();
		var _state4 = this.state;
		var now = _state4.now;
		var past = _state4.past;

		fileReader.onload = function (e) {
			return _this2.setState({
				now: JSON.parse(e.target.result),
				past: cons(now, past),
				future: []
			});
		};
		fileReader.readAsText(document.getElementById("import").files[0], "UTF-8"); // TODO can this be improved? getElementById does not seem to be nice
	},
	_export: function _export() {
		var blob = new Blob([JSON.stringify(this.state.now, null, 2)], { type: "application/json;charset=utf-8" });
		saveAs(blob, "openCPQ.json");
	},
	render: function render() {
		var _this3 = this;

		var _props = this.props;
		var type = _props.type;
		var initialCtxProvider = _props.initialCtxProvider;
		var _state5 = this.state;
		var now = _state5.now;
		var past = _state5.past;
		var future = _state5.future;

		var node = type.makeNode(_extends({}, initialCtxProvider(), {
			value: now,
			updateTo: function updateTo(newValue) {
				return _this3.setState({
					now: newValue,
					past: cons(now, past),
					future: []
				});
			}
		}));
		// TODO the import button should be improved - there are solutions using CSS styling in the web
		return React.createElement(
			"div",
			null,
			React.createElement(
				Navbar,
				{ className: "navbar", fluid: true },
				React.createElement(Nav, { className: "navbar-brand" }),
				React.createElement(
					Nav,
					null,
					React.createElement(
						ButtonToolbar,
						null,
						React.createElement(
							ButtonGroup,
							null,
							React.createElement(
								Button,
								{ className: "navbar-btn", disabled: past.length === 0, onClick: this._undo },
								React.createElement(Glyphicon, { glyph: "step-backward" }),
								" undo"
							),
							React.createElement(
								Button,
								{ className: "navbar-btn", disabled: future.length === 0, onClick: this._redo },
								React.createElement(Glyphicon, { glyph: "step-forward" }),
								" redo"
							)
						),
						React.createElement(
							ButtonGroup,
							null,
							React.createElement(
								Button,
								{ className: "navbar-btn", disabled: past.length === 0, onClick: this._reset },
								React.createElement(Glyphicon, { glyph: "fast-backward" }),
								" reset"
							)
						),
						 // local storage is not always available (e.g., in IE with file: URLs)
						window.localStorage == undefined ? undefined : [React.createElement(
							ButtonGroup,
							null,
							React.createElement(
								Button,
								{ className: "navbar-btn", onClick: this._save },
								React.createElement(Glyphicon, { glyph: "floppy-save" }),
								" save"
							),
							React.createElement(
								Button,
								{ className: "navbar-btn", disabled: localStorage.openCPQ == undefined, onClick: this._restore },
								React.createElement(Glyphicon, { glyph: "floppy-open" }),
								" restore"
							)
						)],
						React.createElement(
							ButtonGroup,
							null,
							React.createElement(
								"form",
								{ className: "navbar-form" },
								React.createElement(Input, { id: "import", type: "file", name: "files" }),
								React.createElement(
									Button,
									{ onClick: this._import },
									React.createElement(Glyphicon, { glyph: "import" }),
									" import"
								),
								React.createElement(
									Button,
									{ disabled: this.state.now == undefined, onClick: this._export },
									React.createElement(Glyphicon, { glyph: "export" }),
									" export"
								)
							)
						)
					)
				)
			),
			React.createElement(
				"div",
				null,
				node.render()
			)
		);
	}
});

function renderTree(type, initialJSON, initialCtxProvider, htmlElement) {
	React.render(React.createElement(RootWidget, { type: type, initialJSON: initialJSON, initialCtxProvider: initialCtxProvider }), htmlElement);
}

module.exports = { renderTree: renderTree };
//# sourceMappingURL=../maps/lib/root.js.map