"use strict";

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require("react");

var _require = require("./base");

var Type = _require.Type;
var Node = _require.Node;

var _require2 = require("./group");

var CGroup = _require2.CGroup;
var cmember = _require2.cmember;

function preprocessColumns(rawColumnsSpec, ctx) {
	var columns = [];
	function process(c) {
		if (c == undefined) {
			// do nothing
		} else if (c instanceof Array) c.forEach(process);else if (c instanceof Function) process(c(ctx));else columns.push(c);
	}
	process(rawColumnsSpec);
	return columns;
}

function CFixedTable(columnsSpec, rows) {
	return new Type("fixedTable", function makeFixedTable(ctx) {
		return new FixedTableNode({ columns: preprocessColumns(columnsSpec, ctx), rows: CGroup(rows).makeNode(ctx) });
	});
}

// TODO handle the case that the cells in a row are not ordered like the columns and some cells are missing or superfluous
// TODO output a row cell only if there is a matching column

var FixedTableNode = (function (_Node) {
	_inherits(FixedTableNode, _Node);

	function FixedTableNode() {
		_classCallCheck(this, FixedTableNode);

		_get(Object.getPrototypeOf(FixedTableNode.prototype), "constructor", this).apply(this, arguments);
	}

	_createClass(FixedTableNode, [{
		key: "render",
		value: function render() {
			var _options = this.__options;
			var columns = _options.columns;
			var rows = _options.rows;

			return React.createElement(
				"table",
				{ className: "fixedTable" },
				React.createElement(
					"colgroup",
					null,
					React.createElement("col", { className: "col-heading" }),
					columns.map(function (_ref) {
						var name = _ref.name;
						return React.createElement("col", { className: "col-" + name });
					})
				),
				React.createElement(
					"tbody",
					null,
					React.createElement(
						"tr",
						null,
						React.createElement("th", null),
						columns.map(function (_ref2) {
							var label = _ref2.label;
							return React.createElement(
								"th",
								null,
								label
							);
						})
					),
					rows.mapMembers(function (_ref3) {
						var row = _ref3.node;

						return React.createElement(
							"tr",
							null,
							React.createElement(
								"td",
								null,
								row.label
							),
							columns.map(function (_ref4) {
								var name = _ref4.name;

								var member = row.inner.member(name);
								var field = member == undefined ? undefined : member.render();
								return React.createElement(
									"td",
									null,
									field
								);
							})
						);
					})
				)
			);
		}
	}]);

	return FixedTableNode;
})(Node);

function crow(name, label, cells) {
	return cmember(name, label, CGroup(cells));
}

module.exports = { CFixedTable: CFixedTable, crow: crow };
//# sourceMappingURL=../maps/lib/fixed-table.js.map